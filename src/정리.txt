

 * 스프링 데이터 jpa는 JPQL을 직접 실행한다. JPQL이 직접 실행되면 항상 SQL이 실행된다 (findById 제외)
 * findById의 경우는 스프링 데이터 JPA가 영속성 컨텍스트에서 엔티티를 조회하는 em.find()를 실행한다.

 정리
 em.find() vs JPQL
 em.find() -> 영속성 컨텍스트를 먼저 조회하고 없으면 SQL을 실행
 JPQL -> SQL을 먼저 실행

 모든 연관관계는 지연로딩으로 설정한다.(중요)


 Eager type이 유용한 경우
   em.find() 한건의 데이터를 조회할때 id로 조회할 때 => Eager type을 join 해서 같이 가져온다 // id로 한건 조회할 때 유용

 하지만 jpql을 사용하는 경우에는 처음에 연관관계 상관 없이 sql문이 실행된다.
 그 이후 연관관계의 type을 보기 때문에 type이 eager로 되어 있으면 eager type의 연관관계를 가져오기 위해 n+1 문제가 생긴다

 @xToOne(OneToOne, ManyToOne) 관계는 기본이 즉시 로딩이므로 직접 지연로딩으로 설정할 것

 컬렉션은 필드에서 초기화 하자. 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
    null 문제에서 안전하다.
    하이버네이트는 엔티티를 영속화 할 때, 컬랙션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.
    만약 getOrders() 처럼 임의의 메서드에서 컬력션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다.
    따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다
    하이버네이트가 컬렉션을 추적하기 위해 내장 클래스로 바꾸었는데 set으로 컬렉션 변경시 추적이 안된다. // 컬렉션을 바꾸면 안됨

 cascade 미사용시
    order 엔티티에서 List<OrderItem> orderItems에 저장할 때
    // 각각 persist 해야한다
    persist(orderItemA)
    persist(orderItemB)
    persist(orderItemC)
    // 각각 저장 데이터 persist한 다음 order에 데이터를 넣고 persist 해야한다
    persist(order)

 cascade 사용시
    persist(order) 만 하면 된다. persist를 전파한다

 cascade는 A를 영속화 할 때 B도 함께 영속화 할지에 대한 내용이다. mappedBy는 관계 없음
    단순하게 A -> B 관계가 cascade로 되어 있으면 A엔티티를 PERSIST할 때 B 엔티티도 연쇄해서 함께 PERSIST 한다.
